# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import os
import types
import unittest
from freezegun import freeze_time
import mandiant_threatintel
import vcr

mock_vcr = vcr.VCR(
    cassette_library_dir="fixtures/VulnerabilityClient",
    decode_compressed_response=True,
    path_transformer=vcr.VCR.ensure_suffix(".yaml"),
)


class Test_Vulnerability_APIResponse(unittest.TestCase):

  def setUp(self) -> None:
    self.mock_base_client: mandiant_threatintel.ThreatIntelClient = (
        unittest.mock.create_autospec(mandiant_threatintel.ThreatIntelClient)
    )

    self.mock_vulnerability_client: mandiant_threatintel.VulnerabilityClient = (
        unittest.mock.create_autospec(mandiant_threatintel.VulnerabilityClient)
    )

  def test_init_vulnerability_from_json(self):
    vulnerability_response = {
        "id": "vulnerability--FAKE-UUID",
        "type": "vulnerability",
        "is_publishable": True,
        "risk_rating": "MEDIUM",
        "analysis": "ANALYSIS",
        "executive_summary": "EXECUTIVE_SUMMARY",
        "description": "DESCRIPTION",
        "exploitation_vectors": ["EXPLOITATION_VECTOR"],
        "title": "TITLE",
        "associated_actors": [],
        "associated_malware": [],
        "associated_reports": [{
            "report_id": "22-00023552",
            "report_type": "Vulnerability Report",
            "title": "ASSOCIATED_REPORT_TITLE",
            "published_date": "2022-10-17T21:32:05.956Z",
            "audience": ["AUDIENCE_NAME"],
        }],
        "exploitation_consequence": "EXPLOITATION_CONSEQUENCE",
        "cwe": "Path Traversal",
        "cve_id": "CVE-YYYY-UNIQUE",
        "vulnerable_products": "VULNERABLE_PRODUCTS",
        "exploitation_state": "No Known",
        "vendor_fix_references": [{
            "url": "VENDOR_FIX_URL",
            "name": "VENDOR_FIX_NAME",
            "unique_id": "VENDOR_FIX_ID",
        }],
        "date_of_disclosure": "2022-10-11T06:00:00.000Z",
        "observed_in_the_wild": False,
        "vulnerable_cpes": [
            {
                "vendor_name": "VENDOR_CPE_NAME",
                "technology_name": "VENDOR_CPE_TECH",
                "cpe": "VENDOR_CPE_CPE",
                "cpe_title": "VENDOR_CPE_TITLE",
            },
        ],
        "was_zero_day": False,
        "workarounds": None,
        "publish_date": "2022-10-17T21:32:00.000Z",
        "updated_date": "2022-10-17T21:32:00.000Z",
        "last_modified_date": "2022-10-17T21:32:00.000Z",
        "available_mitigation": ["Patch"],
        "sources": [{
            "source_name": "SOURCE_NAME",
            "unique_id": "SOURCE_ID",
            "source_description": "SOURCE_DESCRIPTION",
            "date": "2022-10-11T16:00:00.000Z",
            "url": "SOURCE_URL",
            "is_vendor_fix": False,
        }],
        "exploits": [],
        "common_vulnerability_scores": {
            "v2.0": {
                "access_complexity": "HIGH",
                "access_vector": "NETWORK",
                "authentication": "NONE",
                "availability_impact": "COMPLETE",
                "base_score": 7.6,
                "confidentiality_impact": "COMPLETE",
                "exploitability": "UNPROVEN",
                "integrity_impact": "COMPLETE",
                "remediation_level": "OFFICIAL_FIX",
                "report_confidence": "CONFIRMED",
                "temporal_score": 5.6,
                "vector_string": "AV:N/AC:H/Au:N/C:C/I:C/A:C/E:U/RL:OF/RC:C",
            }
        },
        "audience": ["intel_vuln"],
        "intel_free": False,
        "affects_ot": False,
        "aliases": [],
        "cisa_known_exploited": None,
        "cpe_ranges": [],
        "cwe_details": None,
        "days_to_patch": None,
        "epss": None,
        "version_history": [],
        "workarounds_list": [],
    }

    vulnerability = mandiant_threatintel.Vulnerability.from_json_response(
        vulnerability_response, self.mock_base_client
    )

    self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)
    self.assertIsNotNone(vulnerability.id)

  def test_init_vulnerability_from_bad_json(self):
    self.assertRaises(
        ValueError,
        mandiant_threatintel.Vulnerability.from_json_response,
        {},
        self.mock_base_client,
    )

  def test_init_vulnerability_from_identifier(self):
    vulnerability_identifier = "vulnerability--uuid"

    vulnerability = mandiant_threatintel.Vulnerability.from_identifier(
        vulnerability_identifier, self.mock_base_client
    )

    self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)
    self.assertEqual(vulnerability.id, vulnerability_identifier)


class Test_VulnerabilityClient(unittest.TestCase):

  def setUp(self) -> None:
    self.API_KEY = os.environ.get("API_KEY")
    self.SECRET_KEY = os.environ.get("SECRET_KEY")

    if not self.API_KEY or not self.SECRET_KEY:
      self.TOKEN = "FAKE_TOKEN"
      self.base_client = mandiant_threatintel.ThreatIntelClient(
          bearer_token=self.TOKEN
      )
    else:
      self.base_client = mandiant_threatintel.ThreatIntelClient(
          api_key=self.API_KEY, secret_key=self.SECRET_KEY
      )

    self.vulnerability_client: mandiant_threatintel.ThreatIntelClient.VulnerabilityClient = (
        self.base_client.Vulnerabilities
    )

  @mock_vcr.use_cassette
  def test_get_vulnerability_by_uuid(self):
    vulnerability_uuid = "vulnerability--e899a39b-806a-5db5-af54-2a3f71a7087c"

    vulnerability = self.vulnerability_client.get(vulnerability_uuid)

    self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)
    self.assertEqual(vulnerability.id, vulnerability_uuid)
    print(vulnerability.cve_id)
    self.assertIsNotNone(vulnerability.cve_id)

  @mock_vcr.use_cassette
  def test_get_vulnerability_by_cve_id(self):
    vulnerability_cve_id = "CVE-2022-38418"

    vulnerability = self.vulnerability_client.get(vulnerability_cve_id)

    self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)
    self.assertEqual(vulnerability.cve_id, vulnerability_cve_id)
    self.assertIsNotNone(vulnerability.id)

  @mock_vcr.use_cassette
  def test_get_all_attributes(self):
    vulnerability_uuid = "vulnerability--e899a39b-806a-5db5-af54-2a3f71a7087c"

    vulnerability = self.vulnerability_client.get(vulnerability_uuid)

    attributes_list = [
        attr for attr in dir(vulnerability)
        if attr[:1] != "_" and attr[:4] != "from"
    ]
    for attr in attributes_list:
      attr_value = vulnerability.__getattr__(attr)
      if isinstance(attr_value, types.GeneratorType):
        attr_value = list(attr_value)

      print(f"{attr}: {attr_value}")

  @freeze_time(datetime.datetime.fromtimestamp(1668591000))
  @mock_vcr.use_cassette
  def test_get_vulnerability_list_single_page_no_parameters(self):
    start_time = datetime.datetime.fromtimestamp(1662848797)
    vulnerabilities = self.vulnerability_client.get_list(start_epoch=start_time)

    vulnerabilities_list = list(vulnerabilities)

    for vulnerability in vulnerabilities_list:
      with self.subTest():
        self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)

    self.assertEqual(len(vulnerabilities_list), 1)

  @freeze_time(datetime.datetime.fromtimestamp(1668591000))
  @mock_vcr.use_cassette
  def test_get_vulnerability_list_multiple_pages_no_parameters(self):
    start_time = datetime.datetime.fromtimestamp(1662848797)
    vulnerabilities = self.vulnerability_client.get_list(
        start_epoch=start_time, page_size=1
    )

    vulnerabilities_list = list(vulnerabilities)

    for vulnerability in vulnerabilities_list:
      with self.subTest():
        self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)

    self.assertEqual(len(vulnerabilities_list), 2)

  @freeze_time(datetime.datetime.fromtimestamp(1668591000))
  @mock_vcr.use_cassette
  def test_get_vulnerability_list_single_page_with_parameters(self):
    start_time = datetime.datetime.fromtimestamp(1662848797)
    end_time = datetime.datetime.now()
    page_size = 2
    vulnerabilities = self.vulnerability_client.get_list(
        start_epoch=start_time, end_epoch=end_time, page_size=page_size
    )

    vulnerabilities_list = list(vulnerabilities)

    for vulnerability in vulnerabilities_list:
      with self.subTest():
        self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)

    self.assertEqual(len(vulnerabilities_list), 1)

  @freeze_time(datetime.datetime.fromtimestamp(1668591000))
  @mock_vcr.use_cassette
  def test_get_vulnerability_list_multiple_pages_with_parameters(self):
    start_time = datetime.datetime.fromtimestamp(1662848797)
    end_time = datetime.datetime.now()
    vulnerabilities = self.vulnerability_client.get_list(
        start_epoch=start_time, end_epoch=end_time, page_size=1
    )

    vulnerabilities_list = list(vulnerabilities)

    for vulnerability in vulnerabilities_list:
      with self.subTest():
        self.assertIsInstance(vulnerability, mandiant_threatintel.Vulnerability)

    self.assertEqual(len(vulnerabilities_list), 2)


if __name__ == "__main__":
  unittest.main()
